/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./scripts/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./scripts/main.js":
/*!*************************!*\
  !*** ./scripts/main.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! bootstrap */ \"bootstrap\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\") { _typeof = function (_typeof2) { function _typeof(_x) { return _typeof2.apply(this, arguments); } _typeof.toString = function () { return _typeof2.toString(); }; return _typeof; }(function (obj) { return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj); }); } else { _typeof = function (_typeof3) { function _typeof(_x2) { return _typeof3.apply(this, arguments); } _typeof.toString = function () { return _typeof3.toString(); }; return _typeof; }(function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj); }); } return _typeof(obj); }\n\n(function ($) {\n  /*jQuery(document).ready(function($) {\n  if (typeof jQuery != 'undefined') {\n              // jQuery is loaded => print the version\n              alert(\"hey\" + jQuery.fn.jquery);\n      }\n  });*/\n\n  /*!\n      Colorbox 1.6.3\n      license: MIT\n      http://www.jacklmoore.com/colorbox\n  */\n  (function ($, document, window) {\n    var // Default settings object.\n    // See http://jacklmoore.com/colorbox for details.\n    defaults = {\n      // data sources\n      html: false,\n      photo: false,\n      iframe: false,\n      inline: false,\n      // behavior and appearance\n      transition: \"elastic\",\n      speed: 300,\n      fadeOut: 300,\n      width: false,\n      initialWidth: \"600\",\n      innerWidth: false,\n      maxWidth: false,\n      height: false,\n      initialHeight: \"450\",\n      innerHeight: false,\n      maxHeight: false,\n      scalePhotos: true,\n      scrolling: true,\n      opacity: 0.9,\n      preloading: true,\n      className: false,\n      overlayClose: true,\n      escKey: true,\n      arrowKey: true,\n      top: false,\n      bottom: false,\n      left: false,\n      right: false,\n      fixed: false,\n      data: undefined,\n      closeButton: true,\n      fastIframe: true,\n      open: false,\n      reposition: true,\n      loop: true,\n      slideshow: false,\n      slideshowAuto: true,\n      slideshowSpeed: 2500,\n      slideshowStart: \"start slideshow\",\n      slideshowStop: \"stop slideshow\",\n      photoRegex: /\\.(gif|png|jp(e|g|eg)|bmp|ico|webp|jxr|svg)((#|\\?).*)?$/i,\n      // alternate image paths for high-res displays\n      retinaImage: false,\n      retinaUrl: false,\n      retinaSuffix: '@2x.$1',\n      // internationalization\n      current: \"image {current} of {total}\",\n      previous: \"previous\",\n      next: \"next\",\n      close: \"close\",\n      xhrError: \"This content failed to load.\",\n      imgError: \"This image failed to load.\",\n      // accessbility\n      returnFocus: true,\n      trapFocus: true,\n      // callbacks\n      onOpen: false,\n      onLoad: false,\n      onComplete: false,\n      onCleanup: false,\n      onClosed: false,\n      rel: function rel() {\n        return this.rel;\n      },\n      href: function href() {\n        // using this.href would give the absolute url, when the href may have been inteded as a selector (e.g. '#container')\n        return $(this).attr('href');\n      },\n      title: function title() {\n        return this.title;\n      },\n      createImg: function createImg() {\n        var img = new Image();\n        var attrs = $(this).data('cbox-img-attrs');\n\n        if ((typeof attrs === \"undefined\" ? \"undefined\" : _typeof(attrs)) === 'object') {\n          $.each(attrs, function (key, val) {\n            img[key] = val;\n          });\n        }\n\n        return img;\n      },\n      createIframe: function createIframe() {\n        var iframe = document.createElement('iframe');\n        var attrs = $(this).data('cbox-iframe-attrs');\n\n        if ((typeof attrs === \"undefined\" ? \"undefined\" : _typeof(attrs)) === 'object') {\n          $.each(attrs, function (key, val) {\n            iframe[key] = val;\n          });\n        }\n\n        if ('frameBorder' in iframe) {\n          iframe.frameBorder = 0;\n        }\n\n        if ('allowTransparency' in iframe) {\n          iframe.allowTransparency = \"true\";\n        }\n\n        iframe.name = new Date().getTime(); // give the iframe a unique name to prevent caching\n\n        iframe.allowFullscreen = true;\n        return iframe;\n      }\n    },\n        // Abstracting the HTML and event identifiers for easy rebranding\n    colorbox = 'colorbox',\n        prefix = 'cbox',\n        boxElement = prefix + 'Element',\n        // Events\n    event_open = prefix + '_open',\n        event_load = prefix + '_load',\n        event_complete = prefix + '_complete',\n        event_cleanup = prefix + '_cleanup',\n        event_closed = prefix + '_closed',\n        event_purge = prefix + '_purge',\n        // Cached jQuery Object Variables\n    $overlay,\n        $box,\n        $wrap,\n        $content,\n        $topBorder,\n        $leftBorder,\n        $rightBorder,\n        $bottomBorder,\n        $related,\n        $window,\n        $loaded,\n        $loadingBay,\n        $loadingOverlay,\n        $title,\n        $current,\n        $slideshow,\n        $next,\n        $prev,\n        $close,\n        $groupControls,\n        $events = $('<a/>'),\n        // $({}) would be prefered, but there is an issue with jQuery 1.4.2\n    // Variables for cached values or use across multiple functions\n    settings,\n        interfaceHeight,\n        interfaceWidth,\n        loadedHeight,\n        loadedWidth,\n        index,\n        photo,\n        open,\n        active,\n        closing,\n        loadingTimer,\n        publicMethod,\n        div = \"div\",\n        requests = 0,\n        previousCSS = {},\n        init; // ****************\n    // HELPER FUNCTIONS\n    // ****************\n    // Convenience function for creating new jQuery objects\n\n    function $tag(tag, id, css) {\n      var element = document.createElement(tag);\n\n      if (id) {\n        element.id = prefix + id;\n      }\n\n      if (css) {\n        element.style.cssText = css;\n      }\n\n      return $(element);\n    } // Get the window height using innerHeight when available to avoid an issue with iOS\n    // http://bugs.jquery.com/ticket/6724\n\n\n    function winheight() {\n      return window.innerHeight ? window.innerHeight : $(window).height();\n    }\n\n    function Settings(element, options) {\n      if (options !== Object(options)) {\n        options = {};\n      }\n\n      this.cache = {};\n      this.el = element;\n\n      this.value = function (key) {\n        var dataAttr;\n\n        if (this.cache[key] === undefined) {\n          dataAttr = $(this.el).attr('data-cbox-' + key);\n\n          if (dataAttr !== undefined) {\n            this.cache[key] = dataAttr;\n          } else if (options[key] !== undefined) {\n            this.cache[key] = options[key];\n          } else if (defaults[key] !== undefined) {\n            this.cache[key] = defaults[key];\n          }\n        }\n\n        return this.cache[key];\n      };\n\n      this.get = function (key) {\n        var value = this.value(key);\n        return $.isFunction(value) ? value.call(this.el, this) : value;\n      };\n    } // Determine the next and previous members in a group.\n\n\n    function getIndex(increment) {\n      var max = $related.length,\n          newIndex = (index + increment) % max;\n      return newIndex < 0 ? max + newIndex : newIndex;\n    } // Convert '%' and 'px' values to integers\n\n\n    function setSize(size, dimension) {\n      return Math.round((/%/.test(size) ? (dimension === 'x' ? $window.width() : winheight()) / 100 : 1) * parseInt(size, 10));\n    } // Checks an href to see if it is a photo.\n    // There is a force photo option (photo: true) for hrefs that cannot be matched by the regex.\n\n\n    function isImage(settings, url) {\n      return settings.get('photo') || settings.get('photoRegex').test(url);\n    }\n\n    function retinaUrl(settings, url) {\n      return settings.get('retinaUrl') && window.devicePixelRatio > 1 ? url.replace(settings.get('photoRegex'), settings.get('retinaSuffix')) : url;\n    }\n\n    function trapFocus(e) {\n      if ('contains' in $box[0] && !$box[0].contains(e.target) && e.target !== $overlay[0]) {\n        e.stopPropagation();\n        $box.focus();\n      }\n    }\n\n    function setClass(str) {\n      if (setClass.str !== str) {\n        $box.add($overlay).removeClass(setClass.str).addClass(str);\n        setClass.str = str;\n      }\n    }\n\n    function getRelated(rel) {\n      index = 0;\n\n      if (rel && rel !== false && rel !== 'nofollow') {\n        $related = $('.' + boxElement).filter(function () {\n          var options = $.data(this, colorbox);\n          var settings = new Settings(this, options);\n          return settings.get('rel') === rel;\n        });\n        index = $related.index(settings.el); // Check direct calls to Colorbox.\n\n        if (index === -1) {\n          $related = $related.add(settings.el);\n          index = $related.length - 1;\n        }\n      } else {\n        $related = $(settings.el);\n      }\n    }\n\n    function trigger(event) {\n      // for external use\n      $(document).trigger(event); // for internal use\n\n      $events.triggerHandler(event);\n    }\n\n    var slideshow = function () {\n      var active,\n          className = prefix + \"Slideshow_\",\n          click = \"click.\" + prefix,\n          timeOut;\n\n      function clear() {\n        clearTimeout(timeOut);\n      }\n\n      function set() {\n        if (settings.get('loop') || $related[index + 1]) {\n          clear();\n          timeOut = setTimeout(publicMethod.next, settings.get('slideshowSpeed'));\n        }\n      }\n\n      function start() {\n        $slideshow.html(settings.get('slideshowStop')).unbind(click).one(click, stop);\n        $events.bind(event_complete, set).bind(event_load, clear);\n        $box.removeClass(className + \"off\").addClass(className + \"on\");\n      }\n\n      function stop() {\n        clear();\n        $events.unbind(event_complete, set).unbind(event_load, clear);\n        $slideshow.html(settings.get('slideshowStart')).unbind(click).one(click, function () {\n          publicMethod.next();\n          start();\n        });\n        $box.removeClass(className + \"on\").addClass(className + \"off\");\n      }\n\n      function reset() {\n        active = false;\n        $slideshow.hide();\n        clear();\n        $events.unbind(event_complete, set).unbind(event_load, clear);\n        $box.removeClass(className + \"off \" + className + \"on\");\n      }\n\n      return function () {\n        if (active) {\n          if (!settings.get('slideshow')) {\n            $events.unbind(event_cleanup, reset);\n            reset();\n          }\n        } else {\n          if (settings.get('slideshow') && $related[1]) {\n            active = true;\n            $events.one(event_cleanup, reset);\n\n            if (settings.get('slideshowAuto')) {\n              start();\n            } else {\n              stop();\n            }\n\n            $slideshow.show();\n          }\n        }\n      };\n    }();\n\n    function launch(element) {\n      var options;\n\n      if (!closing) {\n        options = $(element).data(colorbox);\n        settings = new Settings(element, options);\n        getRelated(settings.get('rel'));\n\n        if (!open) {\n          open = active = true; // Prevents the page-change action from queuing up if the visitor holds down the left or right keys.\n\n          setClass(settings.get('className')); // Show colorbox so the sizes can be calculated in older versions of jQuery\n\n          $box.css({\n            visibility: 'hidden',\n            display: 'block',\n            opacity: ''\n          });\n          $loaded = $tag(div, 'LoadedContent', 'width:0; height:0; overflow:hidden; visibility:hidden');\n          $content.css({\n            width: '',\n            height: ''\n          }).append($loaded); // Cache values needed for size calculations\n\n          interfaceHeight = $topBorder.height() + $bottomBorder.height() + $content.outerHeight(true) - $content.height();\n          interfaceWidth = $leftBorder.width() + $rightBorder.width() + $content.outerWidth(true) - $content.width();\n          loadedHeight = $loaded.outerHeight(true);\n          loadedWidth = $loaded.outerWidth(true); // Opens inital empty Colorbox prior to content being loaded.\n\n          var initialWidth = setSize(settings.get('initialWidth'), 'x');\n          var initialHeight = setSize(settings.get('initialHeight'), 'y');\n          var maxWidth = settings.get('maxWidth');\n          var maxHeight = settings.get('maxHeight');\n          settings.w = Math.max((maxWidth !== false ? Math.min(initialWidth, setSize(maxWidth, 'x')) : initialWidth) - loadedWidth - interfaceWidth, 0);\n          settings.h = Math.max((maxHeight !== false ? Math.min(initialHeight, setSize(maxHeight, 'y')) : initialHeight) - loadedHeight - interfaceHeight, 0);\n          $loaded.css({\n            width: '',\n            height: settings.h\n          });\n          publicMethod.position();\n          trigger(event_open);\n          settings.get('onOpen');\n          $groupControls.add($title).hide();\n          $box.focus();\n\n          if (settings.get('trapFocus')) {\n            // Confine focus to the modal\n            // Uses event capturing that is not supported in IE8-\n            if (document.addEventListener) {\n              document.addEventListener('focus', trapFocus, true);\n              $events.one(event_closed, function () {\n                document.removeEventListener('focus', trapFocus, true);\n              });\n            }\n          } // Return focus on closing\n\n\n          if (settings.get('returnFocus')) {\n            $events.one(event_closed, function () {\n              $(settings.el).focus();\n            });\n          }\n        }\n\n        var opacity = parseFloat(settings.get('opacity'));\n        $overlay.css({\n          opacity: opacity === opacity ? opacity : '',\n          cursor: settings.get('overlayClose') ? 'pointer' : '',\n          visibility: 'visible'\n        }).show();\n\n        if (settings.get('closeButton')) {\n          $close.html(settings.get('close')).appendTo($content);\n        } else {\n          $close.appendTo('<div/>'); // replace with .detach() when dropping jQuery < 1.4\n        }\n\n        load();\n      }\n    } // Colorbox's markup needs to be added to the DOM prior to being called\n    // so that the browser will go ahead and load the CSS background images.\n\n\n    function appendHTML() {\n      if (!$box) {\n        init = false;\n        $window = $(window);\n        $box = $tag(div).attr({\n          id: colorbox,\n          'class': $.support.opacity === false ? prefix + 'IE' : '',\n          // class for optional IE8 & lower targeted CSS.\n          role: 'dialog',\n          tabindex: '-1'\n        }).hide();\n        $overlay = $tag(div, \"Overlay\").hide();\n        $loadingOverlay = $([$tag(div, \"LoadingOverlay\")[0], $tag(div, \"LoadingGraphic\")[0]]);\n        $wrap = $tag(div, \"Wrapper\");\n        $content = $tag(div, \"Content\").append($title = $tag(div, \"Title\"), $current = $tag(div, \"Current\"), $prev = $('<button type=\"button\"/>').attr({\n          id: prefix + 'Previous'\n        }), $next = $('<button type=\"button\"/>').attr({\n          id: prefix + 'Next'\n        }), $slideshow = $tag('button', \"Slideshow\"), $loadingOverlay);\n        $close = $('<button type=\"button\"/>').attr({\n          id: prefix + 'Close'\n        });\n        $wrap.append( // The 3x3 Grid that makes up Colorbox\n        $tag(div).append($tag(div, \"TopLeft\"), $topBorder = $tag(div, \"TopCenter\"), $tag(div, \"TopRight\")), $tag(div, false, 'clear:left').append($leftBorder = $tag(div, \"MiddleLeft\"), $content, $rightBorder = $tag(div, \"MiddleRight\")), $tag(div, false, 'clear:left').append($tag(div, \"BottomLeft\"), $bottomBorder = $tag(div, \"BottomCenter\"), $tag(div, \"BottomRight\"))).find('div div').css({\n          'float': 'left'\n        });\n        $loadingBay = $tag(div, false, 'position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;');\n        $groupControls = $next.add($prev).add($current).add($slideshow);\n      }\n\n      if (document.body && !$box.parent().length) {\n        $(document.body).append($overlay, $box.append($wrap, $loadingBay));\n      }\n    } // Add Colorbox's event bindings\n\n\n    function addBindings() {\n      function clickHandler(e) {\n        // ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.\n        // See: http://jacklmoore.com/notes/click-events/\n        if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {\n          e.preventDefault();\n          launch(this);\n        }\n      }\n\n      if ($box) {\n        if (!init) {\n          init = true; // Anonymous functions here keep the public method from being cached, thereby allowing them to be redefined on the fly.\n\n          $next.click(function () {\n            publicMethod.next();\n          });\n          $prev.click(function () {\n            publicMethod.prev();\n          });\n          $close.click(function () {\n            publicMethod.close();\n          });\n          $overlay.click(function () {\n            if (settings.get('overlayClose')) {\n              publicMethod.close();\n            }\n          }); // Key Bindings\n\n          $(document).bind('keydown.' + prefix, function (e) {\n            var key = e.keyCode;\n\n            if (open && settings.get('escKey') && key === 27) {\n              e.preventDefault();\n              publicMethod.close();\n            }\n\n            if (open && settings.get('arrowKey') && $related[1] && !e.altKey) {\n              if (key === 37) {\n                e.preventDefault();\n                $prev.click();\n              } else if (key === 39) {\n                e.preventDefault();\n                $next.click();\n              }\n            }\n          });\n\n          if ($.isFunction($.fn.on)) {\n            // For jQuery 1.7+\n            $(document).on('click.' + prefix, '.' + boxElement, clickHandler);\n          } else {\n            // For jQuery 1.3.x -> 1.6.x\n            // This code is never reached in jQuery 1.9, so do not contact me about 'live' being removed.\n            // This is not here for jQuery 1.9, it's here for legacy users.\n            $('.' + boxElement).live('click.' + prefix, clickHandler);\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    } // Don't do anything if Colorbox already exists.\n\n\n    if ($[colorbox]) {\n      return;\n    } // Append the HTML when the DOM loads\n\n\n    $(appendHTML); // ****************\n    // PUBLIC FUNCTIONS\n    // Usage format: $.colorbox.close();\n    // Usage from within an iframe: parent.jQuery.colorbox.close();\n    // ****************\n\n    publicMethod = $.fn[colorbox] = $[colorbox] = function (options, callback) {\n      var settings;\n      var $obj = this;\n      options = options || {};\n\n      if ($.isFunction($obj)) {\n        // assume a call to $.colorbox\n        $obj = $('<a/>');\n        options.open = true;\n      }\n\n      if (!$obj[0]) {\n        // colorbox being applied to empty collection\n        return $obj;\n      }\n\n      appendHTML();\n\n      if (addBindings()) {\n        if (callback) {\n          options.onComplete = callback;\n        }\n\n        $obj.each(function () {\n          var old = $.data(this, colorbox) || {};\n          $.data(this, colorbox, $.extend(old, options));\n        }).addClass(boxElement);\n        settings = new Settings($obj[0], options);\n\n        if (settings.get('open')) {\n          launch($obj[0]);\n        }\n      }\n\n      return $obj;\n    };\n\n    publicMethod.position = function (speed, loadedCallback) {\n      var css,\n          top = 0,\n          left = 0,\n          offset = $box.offset(),\n          scrollTop,\n          scrollLeft;\n      $window.unbind('resize.' + prefix); // remove the modal so that it doesn't influence the document width/height\n\n      $box.css({\n        top: -9e4,\n        left: -9e4\n      });\n      scrollTop = $window.scrollTop();\n      scrollLeft = $window.scrollLeft();\n\n      if (settings.get('fixed')) {\n        offset.top -= scrollTop;\n        offset.left -= scrollLeft;\n        $box.css({\n          position: 'fixed'\n        });\n      } else {\n        top = scrollTop;\n        left = scrollLeft;\n        $box.css({\n          position: 'absolute'\n        });\n      } // keeps the top and left positions within the browser's viewport.\n\n\n      if (settings.get('right') !== false) {\n        left += Math.max($window.width() - settings.w - loadedWidth - interfaceWidth - setSize(settings.get('right'), 'x'), 0);\n      } else if (settings.get('left') !== false) {\n        left += setSize(settings.get('left'), 'x');\n      } else {\n        left += Math.round(Math.max($window.width() - settings.w - loadedWidth - interfaceWidth, 0) / 2);\n      }\n\n      if (settings.get('bottom') !== false) {\n        top += Math.max(winheight() - settings.h - loadedHeight - interfaceHeight - setSize(settings.get('bottom'), 'y'), 0);\n      } else if (settings.get('top') !== false) {\n        top += setSize(settings.get('top'), 'y');\n      } else {\n        top += Math.round(Math.max(winheight() - settings.h - loadedHeight - interfaceHeight, 0) / 2);\n      }\n\n      $box.css({\n        top: offset.top,\n        left: offset.left,\n        visibility: 'visible'\n      }); // this gives the wrapper plenty of breathing room so it's floated contents can move around smoothly,\n      // but it has to be shrank down around the size of div#colorbox when it's done.  If not,\n      // it can invoke an obscure IE bug when using iframes.\n\n      $wrap[0].style.width = $wrap[0].style.height = \"9999px\";\n\n      function modalDimensions() {\n        $topBorder[0].style.width = $bottomBorder[0].style.width = $content[0].style.width = parseInt($box[0].style.width, 10) - interfaceWidth + 'px';\n        $content[0].style.height = $leftBorder[0].style.height = $rightBorder[0].style.height = parseInt($box[0].style.height, 10) - interfaceHeight + 'px';\n      }\n\n      css = {\n        width: settings.w + loadedWidth + interfaceWidth,\n        height: settings.h + loadedHeight + interfaceHeight,\n        top: top,\n        left: left\n      }; // setting the speed to 0 if the content hasn't changed size or position\n\n      if (speed) {\n        var tempSpeed = 0;\n        $.each(css, function (i) {\n          if (css[i] !== previousCSS[i]) {\n            tempSpeed = speed;\n            return;\n          }\n        });\n        speed = tempSpeed;\n      }\n\n      previousCSS = css;\n\n      if (!speed) {\n        $box.css(css);\n      }\n\n      $box.dequeue().animate(css, {\n        duration: speed || 0,\n        complete: function complete() {\n          modalDimensions();\n          active = false; // shrink the wrapper down to exactly the size of colorbox to avoid a bug in IE's iframe implementation.\n\n          $wrap[0].style.width = settings.w + loadedWidth + interfaceWidth + \"px\";\n          $wrap[0].style.height = settings.h + loadedHeight + interfaceHeight + \"px\";\n\n          if (settings.get('reposition')) {\n            setTimeout(function () {\n              // small delay before binding onresize due to an IE8 bug.\n              $window.bind('resize.' + prefix, publicMethod.position);\n            }, 1);\n          }\n\n          if ($.isFunction(loadedCallback)) {\n            loadedCallback();\n          }\n        },\n        step: modalDimensions\n      });\n    };\n\n    publicMethod.resize = function (options) {\n      var scrolltop;\n\n      if (open) {\n        options = options || {};\n\n        if (options.width) {\n          settings.w = setSize(options.width, 'x') - loadedWidth - interfaceWidth;\n        }\n\n        if (options.innerWidth) {\n          settings.w = setSize(options.innerWidth, 'x');\n        }\n\n        $loaded.css({\n          width: settings.w\n        });\n\n        if (options.height) {\n          settings.h = setSize(options.height, 'y') - loadedHeight - interfaceHeight;\n        }\n\n        if (options.innerHeight) {\n          settings.h = setSize(options.innerHeight, 'y');\n        }\n\n        if (!options.innerHeight && !options.height) {\n          scrolltop = $loaded.scrollTop();\n          $loaded.css({\n            height: \"auto\"\n          });\n          settings.h = $loaded.height();\n        }\n\n        $loaded.css({\n          height: settings.h\n        });\n\n        if (scrolltop) {\n          $loaded.scrollTop(scrolltop);\n        }\n\n        publicMethod.position(settings.get('transition') === \"none\" ? 0 : settings.get('speed'));\n      }\n    };\n\n    publicMethod.prep = function (object) {\n      if (!open) {\n        return;\n      }\n\n      var callback,\n          speed = settings.get('transition') === \"none\" ? 0 : settings.get('speed');\n      $loaded.remove();\n      $loaded = $tag(div, 'LoadedContent').append(object);\n\n      function getWidth() {\n        settings.w = settings.w || $loaded.width();\n        settings.w = settings.mw && settings.mw < settings.w ? settings.mw : settings.w;\n        return settings.w;\n      }\n\n      function getHeight() {\n        settings.h = settings.h || $loaded.height();\n        settings.h = settings.mh && settings.mh < settings.h ? settings.mh : settings.h;\n        return settings.h;\n      }\n\n      $loaded.hide().appendTo($loadingBay.show()) // content has to be appended to the DOM for accurate size calculations.\n      .css({\n        width: getWidth(),\n        overflow: settings.get('scrolling') ? 'auto' : 'hidden'\n      }).css({\n        height: getHeight()\n      }) // sets the height independently from the width in case the new width influences the value of height.\n      .prependTo($content);\n      $loadingBay.hide(); // floating the IMG removes the bottom line-height and fixed a problem where IE miscalculates the width of the parent element as 100% of the document width.\n\n      $(photo).css({\n        'float': 'none'\n      });\n      setClass(settings.get('className'));\n\n      callback = function callback() {\n        var total = $related.length,\n            iframe,\n            complete;\n\n        if (!open) {\n          return;\n        }\n\n        function removeFilter() {\n          // Needed for IE8 in versions of jQuery prior to 1.7.2\n          if ($.support.opacity === false) {\n            $box[0].style.removeAttribute('filter');\n          }\n        }\n\n        complete = function complete() {\n          clearTimeout(loadingTimer);\n          $loadingOverlay.hide();\n          trigger(event_complete);\n          settings.get('onComplete');\n        };\n\n        $title.html(settings.get('title')).show();\n        $loaded.show();\n\n        if (total > 1) {\n          // handle grouping\n          if (typeof settings.get('current') === \"string\") {\n            $current.html(settings.get('current').replace('{current}', index + 1).replace('{total}', total)).show();\n          }\n\n          $next[settings.get('loop') || index < total - 1 ? \"show\" : \"hide\"]().html(settings.get('next'));\n          $prev[settings.get('loop') || index ? \"show\" : \"hide\"]().html(settings.get('previous'));\n          slideshow(); // Preloads images within a rel group\n\n          if (settings.get('preloading')) {\n            $.each([getIndex(-1), getIndex(1)], function () {\n              var img,\n                  i = $related[this],\n                  settings = new Settings(i, $.data(i, colorbox)),\n                  src = settings.get('href');\n\n              if (src && isImage(settings, src)) {\n                src = retinaUrl(settings, src);\n                img = document.createElement('img');\n                img.src = src;\n              }\n            });\n          }\n        } else {\n          $groupControls.hide();\n        }\n\n        if (settings.get('iframe')) {\n          iframe = settings.get('createIframe');\n\n          if (!settings.get('scrolling')) {\n            iframe.scrolling = \"no\";\n          }\n\n          $(iframe).attr({\n            src: settings.get('href'),\n            'class': prefix + 'Iframe'\n          }).one('load', complete).appendTo($loaded);\n          $events.one(event_purge, function () {\n            iframe.src = \"//about:blank\";\n          });\n\n          if (settings.get('fastIframe')) {\n            $(iframe).trigger('load');\n          }\n        } else {\n          complete();\n        }\n\n        if (settings.get('transition') === 'fade') {\n          $box.fadeTo(speed, 1, removeFilter);\n        } else {\n          removeFilter();\n        }\n      };\n\n      if (settings.get('transition') === 'fade') {\n        $box.fadeTo(speed, 0, function () {\n          publicMethod.position(0, callback);\n        });\n      } else {\n        publicMethod.position(speed, callback);\n      }\n    };\n\n    function load() {\n      var href,\n          setResize,\n          prep = publicMethod.prep,\n          $inline,\n          request = ++requests;\n      active = true;\n      photo = false;\n      trigger(event_purge);\n      trigger(event_load);\n      settings.get('onLoad');\n      settings.h = settings.get('height') ? setSize(settings.get('height'), 'y') - loadedHeight - interfaceHeight : settings.get('innerHeight') && setSize(settings.get('innerHeight'), 'y');\n      settings.w = settings.get('width') ? setSize(settings.get('width'), 'x') - loadedWidth - interfaceWidth : settings.get('innerWidth') && setSize(settings.get('innerWidth'), 'x'); // Sets the minimum dimensions for use in image scaling\n\n      settings.mw = settings.w;\n      settings.mh = settings.h; // Re-evaluate the minimum width and height based on maxWidth and maxHeight values.\n      // If the width or height exceed the maxWidth or maxHeight, use the maximum values instead.\n\n      if (settings.get('maxWidth')) {\n        settings.mw = setSize(settings.get('maxWidth'), 'x') - loadedWidth - interfaceWidth;\n        settings.mw = settings.w && settings.w < settings.mw ? settings.w : settings.mw;\n      }\n\n      if (settings.get('maxHeight')) {\n        settings.mh = setSize(settings.get('maxHeight'), 'y') - loadedHeight - interfaceHeight;\n        settings.mh = settings.h && settings.h < settings.mh ? settings.h : settings.mh;\n      }\n\n      href = settings.get('href');\n      loadingTimer = setTimeout(function () {\n        $loadingOverlay.show();\n      }, 100);\n\n      if (settings.get('inline')) {\n        var $target = $(href); // Inserts an empty placeholder where inline content is being pulled from.\n        // An event is bound to put inline content back when Colorbox closes or loads new content.\n\n        $inline = $('<div>').hide().insertBefore($target);\n        $events.one(event_purge, function () {\n          $inline.replaceWith($target);\n        });\n        prep($target);\n      } else if (settings.get('iframe')) {\n        // IFrame element won't be added to the DOM until it is ready to be displayed,\n        // to avoid problems with DOM-ready JS that might be trying to run in that iframe.\n        prep(\" \");\n      } else if (settings.get('html')) {\n        prep(settings.get('html'));\n      } else if (isImage(settings, href)) {\n        href = retinaUrl(settings, href);\n        photo = settings.get('createImg');\n        $(photo).addClass(prefix + 'Photo').bind('error.' + prefix, function () {\n          prep($tag(div, 'Error').html(settings.get('imgError')));\n        }).one('load', function () {\n          if (request !== requests) {\n            return;\n          } // A small pause because some browsers will occassionaly report a\n          // img.width and img.height of zero immediately after the img.onload fires\n\n\n          setTimeout(function () {\n            var percent;\n\n            if (settings.get('retinaImage') && window.devicePixelRatio > 1) {\n              photo.height = photo.height / window.devicePixelRatio;\n              photo.width = photo.width / window.devicePixelRatio;\n            }\n\n            if (settings.get('scalePhotos')) {\n              setResize = function setResize() {\n                photo.height -= photo.height * percent;\n                photo.width -= photo.width * percent;\n              };\n\n              if (settings.mw && photo.width > settings.mw) {\n                percent = (photo.width - settings.mw) / photo.width;\n                setResize();\n              }\n\n              if (settings.mh && photo.height > settings.mh) {\n                percent = (photo.height - settings.mh) / photo.height;\n                setResize();\n              }\n            }\n\n            if (settings.h) {\n              photo.style.marginTop = Math.max(settings.mh - photo.height, 0) / 2 + 'px';\n            }\n\n            if ($related[1] && (settings.get('loop') || $related[index + 1])) {\n              photo.style.cursor = 'pointer';\n              $(photo).bind('click.' + prefix, function () {\n                publicMethod.next();\n              });\n            }\n\n            photo.style.width = photo.width + 'px';\n            photo.style.height = photo.height + 'px';\n            prep(photo);\n          }, 1);\n        });\n        photo.src = href;\n      } else if (href) {\n        $loadingBay.load(href, settings.get('data'), function (data, status) {\n          if (request === requests) {\n            prep(status === 'error' ? $tag(div, 'Error').html(settings.get('xhrError')) : $(this).contents());\n          }\n        });\n      }\n    } // Navigates to the next page/image in a set.\n\n\n    publicMethod.next = function () {\n      if (!active && $related[1] && (settings.get('loop') || $related[index + 1])) {\n        index = getIndex(1);\n        launch($related[index]);\n      }\n    };\n\n    publicMethod.prev = function () {\n      if (!active && $related[1] && (settings.get('loop') || index)) {\n        index = getIndex(-1);\n        launch($related[index]);\n      }\n    }; // Note: to use this within an iframe use the following format: parent.jQuery.colorbox.close();\n\n\n    publicMethod.close = function () {\n      if (open && !closing) {\n        closing = true;\n        open = false;\n        trigger(event_cleanup);\n        settings.get('onCleanup');\n        $window.unbind('.' + prefix);\n        $overlay.fadeTo(settings.get('fadeOut') || 0, 0);\n        $box.stop().fadeTo(settings.get('fadeOut') || 0, 0, function () {\n          $box.hide();\n          $overlay.hide();\n          trigger(event_purge);\n          $loaded.remove();\n          setTimeout(function () {\n            closing = false;\n            trigger(event_closed);\n            settings.get('onClosed');\n          }, 1);\n        });\n      }\n    }; // Removes changes Colorbox made to the document, but does not remove the plugin.\n\n\n    publicMethod.remove = function () {\n      if (!$box) {\n        return;\n      }\n\n      $box.stop();\n      $[colorbox].close();\n      $box.stop(false, true).remove();\n      $overlay.remove();\n      closing = false;\n      $box = null;\n      $('.' + boxElement).removeData(colorbox).removeClass(boxElement);\n      $(document).unbind('click.' + prefix).unbind('keydown.' + prefix);\n    }; // A method for fetching the current element Colorbox is referencing.\n    // returns a jQuery object.\n\n\n    publicMethod.element = function () {\n      return $(settings.el);\n    };\n\n    publicMethod.settings = defaults;\n  })(jQuery, document, window);\n})(jQuery);\n\n//# sourceURL=webpack:///./scripts/main.js?");

/***/ }),

/***/ "bootstrap":
/*!****************************!*\
  !*** external "bootstrap" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"bootstrap\");\n\n//# sourceURL=webpack:///external_%22bootstrap%22?");

/***/ })

/******/ });